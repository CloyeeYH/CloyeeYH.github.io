<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSAPP-12]]></title>
    <url>%2F2019%2F02%2F27%2FCSAPP-12%2F</url>
    <content type="text"><![CDATA[逻辑设计和硬件控制语言HCL逻辑设计逻辑门：数字电路的基本计算元素，物理结构与逻辑结构的映射，实质是晶体管。输出是输入的布尔函数。 一个逻辑门计算一位 组合电路需要遵循的原则 两个逻辑门的输出不能连到一起。 组合的电路必须是无环的。输出不能再当输入 HCL表达式与C表达式区分 逻辑门是持续输出的，但C语言表达式是执行到的时候才会求值。这个区别可以把逻辑门当成一个电路来看，电路是不能断电的，电流会一直存在。 C语言中输出可以是任意整数，而HCL只能是1和0。这点比较好理解。 对于a &amp;&amp; b这个符号来说，C语言中的规定是如果前者为假，则后者不会再计算。而HCL当中没有这种说法。 按位计算位相等： 位多路复用器： 多位运算就是多个一位一起运算 32位看是否相等： s的not被多次用到，否则需要32个not门。 HCL条件选择表达式的条件不需要互斥，按照优先顺序依次选取 集合形式的HCL表达式，需要一个输入信号与某些值匹配 储存器和时钟储存器一般两种： 时钟寄存器。储存单个位或单个字，时钟信号控制是否加载输入的值 随机访问储存器。储存多个字，地址来选择 寄存器文件和随即访问储存器有读写操作，时钟寄存器没有读写。 寄存器文件两个读端口，一个写端口，端口都带地址标识操作寄存器。 随即访问储存器只有一个地址输入和一个数据输出]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-11]]></title>
    <url>%2F2019%2F02%2F25%2FCSAPP-11%2F</url>
    <content type="text"><![CDATA[Y86指令体系结构Y86的程序猿可见状态：寄存器，储存器，条件码，PC，程序状态 Y86指令集 halt：终止指令的执行 nop：占位指令，不做任何事 **movl：一系列数据传送指令。r代表寄存器，m代表储存器，i代表立即数。 opl：操作指令 jxx：条件跳转指令，根据后面的条件进行跳转 cmovxx：条件传送指令。xx是条件，只发生在两个寄存器之间 call与ret：方法的调用和返回指令。一个将返回地址入栈，并跳到目标地址。一个将返回地址入PC，并跳到返回地址。 push与pop：入栈和出栈操作 指令编码一般两个寄存器占用一个字节，储存器占四个字节，指令的编码和功能占一个字节。 寄存器的表示：4个二进制位 Y86异常Y86的四种不同状态码：AOK（正常）、HLT（执行halt指令）、ADR（非法地址）、INS（非法指令） Y86程序和x86相似，但有时候Y86需要两条指令来达到X86只要一条即可 eg：addl $4,%ecx]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F02%2F13%2FCSAPP-5%2F</url>
    <content type="text"><![CDATA[title: CSAPP-5date: 2019-02-13 18:26:19tags:CSAPP 代码机器代码 程序计数器（PC）%rip给出将要执行的下一条指令在内存中的地址 整数寄存器文件包含16个命名的位置，储存地址或者整数数据。 条件码寄存器保存最近执行的算术或逻辑指令的状态信息。实现控制或数据流中的条件变化。 一组向量寄存器可以存放一个或多个整数或浮点数值 虚拟地址（64位）的高十六位必须设置为0 查看汇编代码（—&gt;test.s) 1linux&gt; gcc -Og -S test.c 编译并汇编该代码(—&gt;test.o) 1linux&gt; gcc -Og -c test.c GCC产生的汇编代码指令上有后缀，而反汇编代码没有，x86-64的内存引用都是四字长寄存器给出。 反汇编器：根据机器代码生成一种类似于汇编代码的格式。 查看机器代码文件的内容： 1linux&gt; objdump -d matore.o 访问信息整数寄存器： 操作数指示符立即数：常数 ($(C常数表示法)) 寄存器：某个寄存器的内容 内存引用：根据计算出的地址，访问地址 数据传送指令MOV类：把数据从源位置复制到目的位置 源操作数是一个储存在寄存器或者内存中的立即数 目的操作数是个寄存器或者内存地址（位置），不能是立即数寻址 x86-64:两操作数不能都指向内存位置。 指令 描述 movb（8） 传送字节 movw（16） 传送字 movl（32） 传送双字，以寄存器为目的时，把寄存器高位4字节设置为0 movq（64） 传送四字 movabsq 传送绝对的四字 一脸懵逼orz…… 字节传送指令比较（16进制） 指令 描述 movb 不改变其他字节 movsbq 把其他字节设为FF movzbq 把其他字节设为00 压入和弹出栈数据pushq：把数据压入到栈上 popq：弹出数据 %rsp：栈指针，保存栈顶元素地址 压入四字节：先减去8(栈倒过来放），然后将值写入新的栈顶地址。 12subq $8,%rspmovq %rbp,(%rsp) 弹出四字节：读出数据，加上8 12movq（%rsp），%raxaddq $8,%rsp]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-4（浮点数）]]></title>
    <url>%2F2019%2F02%2F11%2FCSAPP-4%2F</url>
    <content type="text"><![CDATA[bomb lab题目都找不到……所以，又回来啃书了…… 舍入 向偶数舍入（默认）：找到最接近的匹配值，如果是5，则使结果的最低有效数字是偶数。 向零舍入：正数向下舍入，负数向上舍入 向上舍入：大于该数的最小整数 向下舍入：不大于该数的最大整数 IEEE浮点表示$$V=(-1)^s\times M\times 2^E$$ 符号位（s），阶码字段(E)，小数字段(M) 规格化的值 E的位模式不全为0也不全为1，此时，阶码的值E=e-Bias(偏置值：单精度：127；双精度：1023)，小数字段:[0,1]. 非规格化的值 阶码域全为0，E=1-Bias 特殊值 阶码全为1。小数域全为0时，得到的值表示无穷（s=0：正无穷，s=1:负无穷），小数域非0，结果值被称为NaN。 整数转换为浮点数创造规格化表示，用IEEE形式编码，构造小数字段，构造阶码字段]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-datalab]]></title>
    <url>%2F2019%2F02%2F11%2FCSAPP-datalab%2F</url>
    <content type="text"><![CDATA[看CSAPP看的实在是绝望，觉得假期肯定啃不完，所以决定先做实验，遇见不会的再翻书，过年这一个多周的时间，做了下datalab bitAnd题目：只能用～和|来实现位的与操作。 bitAnd - x&amp;y using only ~ and | Example: bitAnd(6, 5) = 4 Legal ops: ~ | Max ops: 8 Rating: 1 思路：~x：非x，~y：非y，那么~x|~y就是既不是x也不是y，那~（~x|~y）就是既是x也是y，也就是x与y 1234int bitAnd(int x,int y)&#123; return (~(~x|~y));&#125; getByte 题目：给定n （0&lt;=n&lt;=3），求出x第n个字节是哪数字。 getByte - Extract byte n from word x Bytes numbered from 0 (LSB) to 3 (MSB) Examples: getByte(0x12345678,1) = 0x56 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 6 Rating: 2 思路：（不做题觉得自己了解的还可以，一做题，就觉得，自己啥也没学到……） 第一感觉和CSAPP书上的一道习题挺像，移位运算，用0xFF移动n个字节，然后&amp;一下 123456int getByte(int x,int n)&#123; int temp=x&gt;&gt;((n)&lt;&lt;3); temp=temp&amp;0xFF; return temp;&#125; logicalShift题目：将x按逻辑位移移动n（0&lt;=n&lt;=31）位。 logicalShift - shift x to the right by n, using a logical shift Can assume that 0 &lt;= n &lt;= 31 Examples: logicalShift(0x87654321,4) = 0x08765432 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 20 Rating: 3 思路： 一开始想定义的时候直接unsigned不就好了吗？觉得那这道题就没有意义了。先进行算术右移，然后将右移产生的1mask掉,关键是mask怎么构造，范围是0~31，那1左移31位，然后取反，就是0111……1，然后右移n位，左移1位这样就出来了0…0011…1110，然后加个1，就出来了 123456int logicalShift(int x,int n)&#123; int x1=x&gt;&gt;n; int mask=(~（1&lt;&lt;31)&gt;&gt;n&lt;&lt;1)+1 return X1&amp;mask；&#125; bitCount题目：用位运算计算出x中有多少个1 bitCount - returns count of number of 1’s in word Examples: bitCount(5) = 2, bitCount(7) = 3 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 40 Rating: 4 思路：一位一位的右移，然后看奇偶数，然后进行统计，但是不能用==，/，所以没有了思路。整道题看writeup，还是不懂，看完书再说。分治 bang题目：不用！运算符求出！x结果 bang - Compute !x without using ! Examples: bang(3) = 0, bang(0) = 1 Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 12 Rating: 4 思路：一开始还是想用if，感觉自己还是没找到感觉。这个题就是找0和其他数之间的区别，0|0肯定还是0，但0|1=1，除了0以外，其他数都有1，所以想从这个方面入手。但是没有思路啊，看了别人的才知道，除了0，任何数自己|上自己的相反数最高位一定是1，那就好说了，直接|一下相反数，移位一下就OK 1234567int bang(int x)&#123; int x1=~x+1; x=x|x1; x=x&gt;&gt;31; x=x+1；&#125; tmin题目：返回补码整数的最小整数数值。 tmin - return minimum two’s complement integer Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 4 Rating: 1 思路：这不就是返回一个确定的值吗？ 1234int tmin(void)&#123; return 0x80 &lt;&lt; 24;&#125; fitsBits 题目：只给出n个二进制位，能否表示x,能返回1. fitsBits - return 1 if x can be represented as an n-bit, two’s complement integer. 1 &lt;= n &lt;= 32 Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 15 Rating: 2 思路：因为在前面的bitCount，我在歪路上想了怎么能知道移位移到了最后一位，也就是怎么知道x转为二进制需要多少位，所以这个题就很简单了。将x右移n-1位，判断是不是全1或全0. 1234567int fitsBits(int x, int n)&#123; int x1 =~((~n)+1); x=x&gt;&gt;x1; int ans=(!tmpx|!(tmpx+1)); return ans;&#125; divpwr2题目：给出整数x，整数n，求[x/(2^n)]，答案要接近趋向0方向。 divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 Round toward zero Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 15 Rating: 2 思路：二进制的除就是右移，那就是x&gt;&gt;n.试了一下，只要x是负数，向下取整。首先判断是不是负数，(~( (x &gt;&gt; 31) &amp; 0x1) )+1，是负数构造出0xFF……FF出来，然后构造q=2^n-1 既~((~0)&lt;&lt;n)，如果既然是负数的话就可以加上(tmp &amp; q) 既 0x0…FFF，再右移动n位。 1234567int divpwr2(int x, int n)&#123; int tmp = (~( (x &gt;&gt; 31) &amp; 0x1) )+1 ; int q= ~((~0)&lt;&lt;n); int ans = (x + (tmp &amp; q) ) &gt;&gt; n ; return ans;&#125; negate题目：求相反数 negate - return -x Example: negate(1) = -1. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 5 Rating: 2 1234int negate(int x)&#123; return ((~x)+1)&#125; isPositive 题目:判断x是不是正数 isPositive - return 1 if x &gt; 0, return 0 otherwise Example: isPositive(-1) = 0. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 8 Rating: 3 思路：因为有0，所以不能看符号位，那就转换一下思路，取反，如果0，那么结果是1，如果为负数，那结果为正数，符号位为1，如果x为0或负数，那么!x | (x &gt;&gt; 31) != 0，再！一下就OK了 1234int isPositive(int x)&#123; return !(!x|(x&gt;&gt;31)); &#125; isLessOrEqual题目：用位运算判定x&lt;=y，如果是就返回1，如果不是就返回0。 isLessOrEqual - if x &lt;= y then return 1, else return 0 Example: isLessOrEqual(4,5) = 1. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 24 Rating: 3 思路：分两种情况，同号和异号，异号比较一下符号位就好，同号x-y的符号位是不是0. 123456789int isLessOrEqual(int x, int y)&#123; int signx = (x &gt;&gt; 31); int signy = (y &gt;&gt; 31); int isSameSign=!(signx^signy) ; int p=!(((~x)+1+y)&gt;&gt;31); int ans=(isSameSign&amp;p)|((!isSameSign)&amp;signx); return ans;&#125; ilog2 题目：求整数的log(x)。 ilog2 - return floor(log base 2 of x), where x &gt; 0 Example: ilog2(16) = 4 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 90 Rating: 4 思路：感觉和之前C程里解方程的实验应该差不多。二分法找最高位为1的位置。 12345678910int ilog2(int x)&#123; int num=0; num=(!!(x&gt;&gt;16))&lt;&lt;4; num=num+((!!(x&gt;&gt;(8+num)))&lt;&lt;3); num=num+((!!(x&gt;&gt;(4+num)))&lt;&lt;2); num=num+((!!(x&gt;&gt;(2+num)))&lt;&lt;1); num=num+((!!(x&gt;&gt;(1+num)))&lt;&lt;0); return num;&#125; float_neg题目：返回输入uf的负数形式-uf。如果uf是NAN形式就直接返回参数。 float_neg - Return bit-level equivalent of expression -f for floating point argument f. Both the argument and result are passed as unsigned int’s, but they are to be interpreted as the bit-level representations of single-precision floating point values. When argument is NaN, return argument. Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while Max ops: 10 Rating: 2 思路：题目读不懂，翻书+google，uf：unsigned float ； NaN（非数）:未定义或不可表示的值，先判断是不是NaN(&gt;0x2f800000)，是就直接返回，不是则取反 123456789unsigned float_neg(unsigned uf)&#123; unsigned result; unsigned tmp; result=uf^0x80000000; tmp=uf&amp;0x7fffffff; if(tmp&gt;0x7f800000) result=uf; return result;&#125; float_i2f题目：将int型的x转为float型的x。 float_i2f - Return bit-level equivalent of expression (float) x Result is returned as unsigned int, but it is to be interpreted as the bit-level representation of a single-precision floating point values. Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while Max ops: 30 Rating: 4 思路：没思路，翻书，感觉一到浮点数就一脸懵逼，完全没有概念，又是一道把别人的答案从头到尾看了好几遍的题，等看完书再说叭（头秃……）。 如果是0，直接返回即可 如果是0x80000000,返回0xcf000000 如果负数：变为整正数之后按照正数计算 正数：计算尾数部分左移还是右移，然后计算阶码，加上偏置值127，尾数向偶数舍入。 float_twice题目：就是将浮点数乘以2倍。 float_twice - Return bit-level equivalent of expression 2*f for floating point argument f. Both the argument and result are passed as unsigned int’s, but they are to be interpreted as the bit-level representation of single-precision floating point values. When argument is NaN, return argument Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while Max ops: 30 Rating: 4 嘤嘤嘤~浮点数真令人头大]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP_3]]></title>
    <url>%2F2019%2F02%2F01%2FCSAPP-3%2F</url>
    <content type="text"><![CDATA[无符号数编码$$B2U_\omega(\vec x)=\sum^{\omega-1}_{i=0}x_i2^i$$ $$eg:B2U_4([0001])=0•2^3+0•2^2+0•2^1+1•2^0=0+0+0+1=1$$ 无符号数编码唯一性 双射 补码编码$$B2T_\omega(\vec x)=-x_{\omega-1}2^{\omega-1}+\sum^{\omega-2}_{i=0}x_i2^i$$ 二进制数编码表示 原码 最左边一位为符号位（小数：小数点左边一位为符号位） +：0 —：1 反码 符号位不变，其他取反 补码 负数：反码末尾加一 正数：本身 有符号数和无符号数的转换 补码转换为无符号数$$T2U_\omega(x)=\begin{cases}x+2^\omega, x&lt;0\x,x\geq0\\end{cases}$$ 无符号数转换为补码$$U2T_\omega(u)=-u_{\omega-1}2^\omega+u$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP_2]]></title>
    <url>%2F2019%2F01%2F30%2FCSAPP-2%2F</url>
    <content type="text"><![CDATA[寻址和字节顺序 小端法：最低有效字节在最前面 大端法：最高有效字节在最前面 浮点型和整型数据有不同的字节模式 二进制代码不兼容 布尔代数 布尔运算 逻辑运算 ~ NOT &amp; AND 单竖线 OR ^ 异或（不同为1，相同为0） 位向量：固定长度，由0，1组成的串,1表示存在，0表示不存在，从右往左 布尔环 移位运算左移：右端补k个0，移位之后符号为不变，将一个整数左移1位相当于乘以2 逻辑右移：左端补k个0 算术右移：左端补k个最高有效位的值 意义 x&gt;&gt;k x右移k位 x&lt;&lt;k x左移k位 位级运算转换为二进制进行运算，之后转回相应进制 掩码运算 最常见：ch&amp;0xff，生成由ch最低有效字节组成的值 0xff的二进制形式为11111111，这样最终的值为最后8位不变，其他数均为0]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP_1]]></title>
    <url>%2F2019%2F01%2F27%2FCSAPP-1%2F</url>
    <content type="text"><![CDATA[计算机系统 硬件 总线：贯穿整个系统的电子管道 I/O设备：系统和外部联系的通道 主存：执行程序时，存放相关数据 处理器：解释或执行储存在主存中指令中的引擎 软件 应用程序 操作系统 虚拟内存 C全局变量相对应的数据位紧跟在代码后面，一开始被制订大小 堆：紧跟在代码和数据区后面，可动态扩展和收缩 共享库 栈：虚拟地址空间顶部，实现函数调用，可动态扩展收缩 内核虚拟内存：地址空间顶部 并发和并行 并发：同时有多个活动的系统 并行：用并发使一个系统运行更快 抽象 文件是对I/O设备的抽象 虚拟内存是对主存和磁盘的抽象 进程是对正在运行的程序的抽象 虚拟机是对整个计算机的抽象]]></content>
  </entry>
  <entry>
    <title><![CDATA[ss科学上网]]></title>
    <url>%2F2019%2F01%2F26%2Fss%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[嗯……第一次更博，有点晚了，一直在弄，期间走了不少弯路，今天可算是弄好了。 一、vultr注册—&gt;绑定银行卡—&gt;建服务器 前两个就不细说了 Server Location: sydney Server Type：centos7 x64 Server Size: 按实际需要选 Deploy Now 接下来是漫长的等待…… 二、连接及搭建ss连接：1$ ssh root@IP 之后有一个要输入yes 之后是密码 一键搭建ss123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 之后按照提示输入IP、端口、密码、加密方式 出现红框框的时候，恭喜，快要成功了…… 三、shadowsocks下载shadowsocks，然后打开，填好IP端口密码加密方式，其他默认就好。确定 bingo~ 以下为我走的弯路学到的知识一、新建centos7虚拟机 准备 VMware workstation 14 、镜像（https://www.centos.org/download/） 具体步骤 安装程序光盘映像文件，找到下载的路径 命名，选择位置 确定磁盘大小和是否拆分为多个文件 自定义硬件 选择使用ISO映像文件，并找到映像文件的路径 完成之后就可以打开虚拟机了 点黑色的地方，用上下键选第一条，漫长的等待…… 选择语言（ENGLISH） 确定日期和时间，语言，软件选择—&gt;GNOME桌面，开始安装 之后设置root和新建用户 这次是非常漫长的等待…… reboot! 设置网络，登陆，bingo~ 二、端口放行（操作防火墙）主要是三个命令 123firewall-cmd --zone=public --add-port=80/tcp --permanent //--zone :作用域 80/tcp:端口/传输协议 --permanent：没有这个重启以后还得再来一遍firewall-cmd --reloadiptables-save 第一条命令是添加端口，第二条命令是重载防火墙，第三条命令是查看开放的端口 ##同时用到的对防火墙的操作 1234firewall-cmd --state //查看防火墙状态systemctl stop firewalld.service //关闭防火墙systemctl start firewalld.service //开启防火墙systemctl disable firewalld.service //禁止firewall开机启动]]></content>
  </entry>
</search>
