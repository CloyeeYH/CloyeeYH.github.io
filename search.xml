<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[fatal-unable-to-auto-detect-email-address]]></title>
    <url>%2F2019%2F08%2F19%2Ffatal-unable-to-auto-detect-email-address%2F</url>
    <content type="text"><![CDATA[五个月没开博客，我的git他有了自己的想法。。。 git: fatal unable to auto-detect email address (got &quot;some wrong email&quot;) 解决方法： 1$ git config --global user.email &quot;you@example.com&quot; 1$ git config --local -l]]></content>
  </entry>
  <entry>
    <title><![CDATA[JAVA一丢丢]]></title>
    <url>%2F2019%2F08%2F19%2FJAVA%E4%B8%80%E4%B8%A2%E4%B8%A2%2F</url>
    <content type="text"><![CDATA[这就开始学习了？？ 暑假看了一点点java，之后一个月就是java实习了，来一个分界线☟☟☟ 基本数据类型 ‘syso‘ ’alt‘+’/‘&#10233;System.out.println(); Float.MAX_VALUE获取float max println：输出后自动换行，print：输出后不换行 数组定义： 12int[] a; a = new int[5]; public static final 则为常量 1970年1月1日 8点0分0秒开始 extends继承 短路与（&amp;&amp;）：第一个false ，不执行第二个（常用，效率高） 不短路与（&amp;）：第一个false，第二个也要执行 面向对象1234Person zhangsan; //定义一个对象zhangsan=person();//实例化对象zhangsan.name="zhangsan";//给对象的属性赋值zangsan.age=23; 快捷方式 ‘syso‘ ’ALT‘+’/‘&#10233;System.out.println(); 选中 CTRL + SHIFYT + / &#10233;多行注释 ‘main’ ‘ALT’ + ‘/‘&#10233;public static void main(String []args) ‘CTRL’ + ‘SHIFT’ +’o’&#10233;自动导包 ‘’CTRL’ + ‘1’ &#10233;接口实现 多线程继承线程类首先准备一个独立的线程类，（继承thread） 重写run方法，启动线程用start；机制视频9：00 实现Runnable接口一个类，实现runnable接口，因为没继承thread，所以没有start方法 所以要创建一个thread对象，把battle1作为thread对象的参数扔进去 匿名类]]></content>
  </entry>
  <entry>
    <title><![CDATA[Bomb Lab]]></title>
    <url>%2F2019%2F03%2F26%2FBomb-Lab%2F</url>
    <content type="text"><![CDATA[题的意思：输入六个字符串，让explode_bomb函数不执行，否则就爆炸 phase_1由callq指令可以得知，phase_1调用了strings_not_equal，并将返回值存储于%eax中，test指令计算%eax的值是否等于0，je指令决定是否跳转，若%eax的值等于0，跳转至0x400ef7处，也就是安全区域，拆弹成功，否则不跳转，即执行explode_bomb，拆弹失败。通过以上分析，可以得知phase_1的关键在于控制strings_not_equal的返回值 在执行callq strings_not_equal指令之前，mov $0x402400,%esi将常数0x402400传递至%esi，%esi的值是strings_not_equal数的第二个参数，第一个参数则是我们输入的值。因此，要得到%esi值。 利用gdb对bomb进行调试 在phase_1处设置断点 通过disassemble对当前函数进行反编译 使用stepi对指令进行单步调试 运行phase_1第一条指令的初始状态 1234567890000000000400ee0 &lt;phase_1&gt;: 400ee0: 48 83 ec 08 sub $0x8,%rsp 400ee4: be 00 24 40 00 mov $0x402400,%esi #%esi存0x402400的值 400ee9: e8 4a 04 00 00 callq 401338 &lt;strings_not_equal&gt; #调用函数（见下） 400eee: 85 c0 test %eax,%eax #计算%eax的值是否等于0 400ef0: 74 05 je 400ef7 &lt;phase_1+0x17&gt; #若%eax的值等于0，则跳转至0x400ef7处，成功 400ef2: e8 43 05 00 00 callq 40143a &lt;explode_bomb&gt; 400ef7: 48 83 c4 08 add $0x8,%rsp 400efb: c3 retq 在进入phase_1之前，read_line函数从终端读取输入 通过stepi单步执行指令 直至指令mov $0x402400,%esi执行完毕（此时，strings_not_equal函数的第二个参数已经存储于%esi） 通过print打印%esi的值，可以得知%esi存储的是一个内存地址（因为参数类型是字符串类型，因此寄存器存储的是内存地址，而非确切的字符串值） 打印位于地址%esi处的内容 1234567891011121314151617181920212223242526272829303132333435363738390000000000401338 &lt;strings_not_equal&gt;: 401338: 41 54 push %r12 40133a: 55 push %rbp 40133b: 53 push %rbx 40133c: 48 89 fb mov %rdi,%rbx #%rbx存了%rdi（第一个参数）的值 40133f: 48 89 f5 mov %rsi,%rbp #%rbp存了%rsi（第二个参数）的值 401342: e8 d4 ff ff ff callq 40131b &lt;string_length&gt; #调用函数（字符串长度） 401347: 41 89 c4 mov %eax,%r12d #%r12d存了返回值 40134a: 48 89 ef mov %rbp,%rdi #%rdi存了%rbp的值（0x402400的值） 40134d: e8 c9 ff ff ff callq 40131b &lt;string_length&gt; #再次调用字符串长度函数 401352: ba 01 00 00 00 mov $0x1,%edx 401357: 41 39 c4 cmp %eax,%r12d 40135a: 75 3f jne 40139b &lt;strings_not_equal+0x63&gt; #input长度不等于52，跳到40139b，返回值就是1，所以input长度必须为52 40135c: 0f b6 03 movzbl (%rbx),%eax #%rbx的值赋给返回值，如果为0，就跳转 40135f: 84 c0 test %al,%al 401361: 74 25 je 401388 &lt;strings_not_equal+0x50&gt; 401363: 3a 45 00 cmp 0x0(%rbp),%al #对%rbp（0x402400处的值)取值，和%al（input的第一个字符）比较 401366: 74 0a je 401372 &lt;strings_not_equal+0x3a&gt; #相同就跳转到401372，不同返回值为1 401368: eb 25 jmp 40138f &lt;strings_not_equal+0x57&gt; 40136a: 3a 45 00 cmp 0x0(%rbp),%al #此时%al存的是input的第一个字符？？ 40136d: 0f 1f 00 nopl (%rax) 401370: 75 24 jne 401396 &lt;strings_not_equal+0x5e&gt; 401372: 48 83 c3 01 add $0x1,%rbx #%eax取input的下一个值 401376: 48 83 c5 01 add $0x1,%rbp 40137a: 0f b6 03 movzbl (%rbx),%eax #%rbp去内存地址的下一个值， 40137d: 84 c0 test %al,%al #比较 40137f: 75 e9 jne 40136a &lt;strings_not_equal+0x32&gt; #不相等就跳转到40136a，也就是%eax为1的地方，所以必须相同 401381: ba 00 00 00 00 mov $0x0,%edx 401386: eb 13 jmp 40139b &lt;strings_not_equal+0x63&gt; 401388: ba 00 00 00 00 mov $0x0,%edx 40138d: eb 0c jmp 40139b &lt;strings_not_equal+0x63&gt; 40138f: ba 01 00 00 00 mov $0x1,%edx 401394: eb 05 jmp 40139b &lt;strings_not_equal+0x63&gt; 401396: ba 01 00 00 00 mov $0x1,%edx 40139b: 89 d0 mov %edx,%eax 40139d: 5b pop %rbx 40139e: 5d pop %rbp 40139f: 41 5c pop %r12 4013a1: c3 retq phase_212345678910111213141516171819202122232425260000000000400efc &lt;phase_2&gt;: 400efc: 55 push %rbp 400efd: 53 push %rbx 400efe: 48 83 ec 28 sub $0x28,%rsp 400f02: 48 89 e6 mov %rsp,%rsi 400f05: e8 52 05 00 00 callq 40145c &lt;read_six_numbers&gt; #调用读取六个数字的函数 400f0a: 83 3c 24 01 cmpl $0x1,(%rsp) #比较1和%rsp 400f0e: 74 20 je 400f30 &lt;phase_2+0x34&gt; #是1则安全 400f10: e8 25 05 00 00 callq 40143a &lt;explode_bomb&gt; #否则爆炸 400f15: eb 19 jmp 400f30 &lt;phase_2+0x34&gt; #跳到400f30 400f17: 8b 43 fc mov -0x4(%rbx),%eax #使%eax的值等于M[%rbx-4]的值，即M[%rsp]的值，即第一个数的值 400f1a: 01 c0 add %eax,%eax #%eax的值扩大两倍 400f1c: 39 03 cmp %eax,(%rbx) #比较 400f1e: 74 05 je 400f25 &lt;phase_2+0x29&gt; #相同就跳到安全区 400f20: e8 15 05 00 00 callq 40143a &lt;explode_bomb&gt; #不同爆炸 400f25: 48 83 c3 04 add $0x4,%rbx #%rbx储存下一个数的值 400f29: 48 39 eb cmp %rbp,%rbx #与%rbp比较 400f2c: 75 e9 jne 400f17 &lt;phase_2+0x1b&gt; #不相同跳到 400f17 400f2e: eb 0c jmp 400f3c &lt;phase_2+0x40&gt; 400f30: 48 8d 5c 24 04 lea 0x4(%rsp),%rbx #将%rsp的值加4并存储于%rbx——&gt;下一个数的地址值 400f35: 48 8d 6c 24 18 lea 0x18(%rsp),%rbp#控制循环次数，六个整型24字节0x81 400f3a: eb db jmp 400f17 &lt;phase_2+0x1b&gt; #跳到400f17 400f3c: 48 83 c4 28 add $0x28,%rsp 400f40: 5b pop %rbx 400f41: 5d pop %rbp 400f42: c3 retq 由callq 40145c read_six_numbers可知，phase_2调用了read_six_numbers函数并读取了6个数值。 根据cmpl $0x1,(%rsp)可知，若地址%rsp处的值等于1，那么进入安全区域，否则就会引爆炸弹。 由此可以得知，我们输入的第1个数字应该为1。 然后phase_2跳转至0x400f30处执行指令lea 0x4(%rsp),%rbx（该指令的效果是将%rsp的值加4并存储于%rbx）这意味着%rbx的值实际上是下一个数的地址值。 lea 0x18(%rsp),%rbp用于控制循环的次数，6个整型共占用24字节，恰好等于0x18。 接着phase_2跳转至0x400f17处执行mov -0x4(%rbx),%eax指令（该指令的效果是使%eax的值等于M[%rbx-4]的值，即M[%rsp]的值，也就是第1个数的值） add %eax,%eax使%eax的值扩大为原来的2倍 cmp %eax,(%rbx)将下一个数的值与%eax的值作比较，若相等则跳转至安全区域0x400f25，否则拆弹失败。 0x400f25处的指令为add $0x4,%rbx（该指令的效果是使%rbx存储下一个数的地址） 与%rbp的值比较并在不相等的情况下跳转至0x400f17处循环执行指令。 综上，phase_2通过%rbx来获取输入的6个数字，通过%eax来控制比较的数值大小，%eax初始化为第1个数字的值，并在每次循环后增长至原来的2倍，一共6次循环。所以phase_2的解为1 2 4 8 16 32。 phase_3123456789101112131415161718192021222324252627282930313233343536370000000000400f43 &lt;phase_3&gt;: 400f43: 48 83 ec 18 sub $0x18,%rsp 400f47: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 400f4c: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 400f51: be cf 25 40 00 mov $0x4025cf,%esi 400f56: b8 00 00 00 00 mov $0x0,%eax 400f5b: e8 90 fc ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; #调用函数 400f60: 83 f8 01 cmp $0x1,%eax 400f63: 7f 05 jg 400f6a &lt;phase_3+0x27&gt; 400f65: e8 d0 04 00 00 callq 40143a &lt;explode_bomb&gt; 400f6a: 83 7c 24 08 07 cmpl $0x7,0x8(%rsp) #输入的第一个数与7作比较 400f6f: 77 3c ja 400fad &lt;phase_3+0x6a&gt; # 大于7，失败 400f71: 8b 44 24 08 mov 0x8(%rsp),%eax #否则执行函数，将第一个数字储存在%eax里 400f75: ff 24 c5 70 24 40 00 jmpq *0x402470(,%rax,8) #间接跳转，gdb 400f7c: b8 cf 00 00 00 mov $0xcf,%eax 400f81: eb 3b jmp 400fbe &lt;phase_3+0x7b&gt; 400f83: b8 c3 02 00 00 mov $0x2c3,%eax 400f88: eb 34 jmp 400fbe &lt;phase_3+0x7b&gt; 400f8a: b8 00 01 00 00 mov $0x100,%eax 400f8f: eb 2d jmp 400fbe &lt;phase_3+0x7b&gt; 400f91: b8 85 01 00 00 mov $0x185,%eax 400f96: eb 26 jmp 400fbe &lt;phase_3+0x7b&gt; 400f98: b8 ce 00 00 00 mov $0xce,%eax 400f9d: eb 1f jmp 400fbe &lt;phase_3+0x7b&gt; 400f9f: b8 aa 02 00 00 mov $0x2aa,%eax 400fa4: eb 18 jmp 400fbe &lt;phase_3+0x7b&gt; 400fa6: b8 47 01 00 00 mov $0x147,%eax 400fab: eb 11 jmp 400fbe &lt;phase_3+0x7b&gt; 400fad: e8 88 04 00 00 callq 40143a &lt;explode_bomb&gt; 400fb2: b8 00 00 00 00 mov $0x0,%eax 400fb7: eb 05 jmp 400fbe &lt;phase_3+0x7b&gt; 400fb9: b8 37 01 00 00 mov $0x137,%eax 400fbe: 3b 44 24 0c cmp 0xc(%rsp),%eax 400fc2: 74 05 je 400fc9 &lt;phase_3+0x86&gt; 400fc4: e8 71 04 00 00 callq 40143a &lt;explode_bomb&gt; 400fc9: 48 83 c4 18 add $0x18,%rsp 400fcd: c3 retq 12340000000000400bf0 &lt;__isoc99_sscanf@plt&gt;: 400bf0: ff 25 92 24 20 00 jmpq *0x202492(%rip) #603088&lt;__isoc99_sscanf@GLIBC_2.7&gt; 400bf6: 68 11 00 00 00 pushq $0x11 400bfb: e9 d0 fe ff ff jmpq 400ad0 &lt;.plt&gt; mov $0x4025cf,%esi这条指令，常数0x4025cf应该是个内存地址，打印该内存地址的值 把%d %d与 callq 400bf0 _isoc99_sscanf@plt 这条指令联系起来大概就是输入两个数 scanf函数的返回值存储于%eax，该值代表输入值的个数，cmp $0x1,%eax将%eax的值与1做比较，如果输入值的个数大于1，跳转至安全区域，即指令`cmpl $0x7,0x8(%rsp)相同跳到安全处，否则拆弹失败。 cmpl $0x7,0x8(%rsp)将输入的第一个数以6为例，与7作比较，如果大于7，那么拆弹失败，否则执行指令mov 0x8(%rsp),%eax（该指令将第一个数存储于%eax中）。 接着执行指令jmpq *0x402470(,%rax,8)，该指令是一个间接跳转指令，通过gdb得到执行该指令后的跳转位置，如下图所示。 跳到mov $0x2aa,%eax指令将常数0x2aa移至%eax， 然后执行jmp 0x400fbe &lt;phase_3+123&gt;跳转至0x400fbe处执行指令cmp 0xc(%rsp),%eax（该指令将第二个数与%eax做比较，若相等，安全退出，拆弹成功，否则拆弹失败） 0x2aa的十进制值为682，所以输入的两个数应为6，682。 第一个数只要小于7即可。当第一个数的取值改变，那么在获取第二个数时会跳转到不同的分支，因此会得到不同的值。（5——&gt;206) phase_41234567891011121314151617181920212223000000000040100c &lt;phase_4&gt;: 40100c: 48 83 ec 18 sub $0x18,%rsp 401010: 48 8d 4c 24 0c lea 0xc(%rsp),%rcx 401015: 48 8d 54 24 08 lea 0x8(%rsp),%rdx 40101a: be cf 25 40 00 mov $0x4025cf,%esi #和3一样 40101f: b8 00 00 00 00 mov $0x0,%eax 401024: e8 c7 fb ff ff callq 400bf0 &lt;__isoc99_sscanf@plt&gt; 401029: 83 f8 02 cmp $0x2,%eax #scanf函数返回值和2比较 40102c: 75 07 jne 401035 &lt;phase_4+0x29&gt; #不等于则会引爆炸弹 40102e: 83 7c 24 08 0e cmpl $0xe,0x8(%rsp) #否则执行 401033: 76 05 jbe 40103a &lt;phase_4+0x2e&gt; 401035: e8 00 04 00 00 callq 40143a &lt;explode_bomb&gt; 40103a: ba 0e 00 00 00 mov $0xe,%edx #%edx是14 40103f: be 00 00 00 00 mov $0x0,%esi 401044: 8b 7c 24 08 mov 0x8(%rsp),%edi 401048: e8 81 ff ff ff callq 400fce &lt;func4&gt; #调用func4 40104d: 85 c0 test %eax,%eax #检测返回值是否为0 40104f: 75 07 jne 401058 &lt;phase_4+0x4c&gt; #不等于0则爆炸 401051: 83 7c 24 0c 00 cmpl $0x0,0xc(%rsp) #将输入的第二个数与0做比较 401056: 74 05 je 40105d &lt;phase_4+0x51&gt; #如果相等，那么phase_4正常退出，拆弹成功 401058: e8 dd 03 00 00 callq 40143a &lt;explode_bomb&gt; 40105d: 48 83 c4 18 add $0x18,%rsp 401061: c3 retq 12345678910111213141516171819202122230000000000400fce &lt;func4&gt;: 400fce: 48 83 ec 08 sub $0x8,%rsp 400fd2: 89 d0 mov %edx,%eax 400fd4: 29 f0 sub %esi,%eax 400fd6: 89 c1 mov %eax,%ecx 400fd8: c1 e9 1f shr $0x1f,%ecx 400fdb: 01 c8 add %ecx,%eax 400fdd: d1 f8 sar %eax 400fdf: 8d 0c 30 lea (%rax,%rsi,1),%ecx 400fe2: 39 f9 cmp %edi,%ecx 400fe4: 7e 0c jle 400ff2 &lt;func4+0x24&gt; 400fe6: 8d 51 ff lea -0x1(%rcx),%edx 400fe9: e8 e0 ff ff ff callq 400fce &lt;func4&gt; 400fee: 01 c0 add %eax,%eax 400ff0: eb 15 jmp 401007 &lt;func4+0x39&gt; 400ff2: b8 00 00 00 00 mov $0x0,%eax 400ff7: 39 f9 cmp %edi,%ecx 400ff9: 7d 0c jge 401007 &lt;func4+0x39&gt; 400ffb: 8d 71 01 lea 0x1(%rcx),%esi 400ffe: e8 cb ff ff ff callq 400fce &lt;func4&gt; 401003: 8d 44 00 01 lea 0x1(%rax,%rax,1),%eax 401007: 48 83 c4 08 add $0x8,%rsp 40100b: c3 retq 和phase_3类似，首先将内存地址为0x4025cf的内容打印出来，如下图所示。 由此得知，输入应该为2个整数。 在执行 callq 400bf0 __isoc99_sscanf@plt 指令后，返回值存储于%eax， 然后判断%eax的值是否等于2，若不等于则会引爆炸弹，否则执行指令cmpl $0xe,0x8(%rsp)，该指令将输入的第一个数与常数0xe做比较，根据jbe 40103a &lt;phase_4+0x2e&gt;，如果输入的第一个数大于0xe，那么拆弹失败，否则跳转到0x40103a处执行mov $0xe,%edx指令。 接下来调用了函数func4，而 mov $0xe,%edx、mov $0x0 , %esi和 mov 0x8(%rsp) , %edi 这三条指令用于设置func4的参数（第一个、第二个和第三个参数分别存储于寄存器%edi、%esi和%edx,%rsp为栈指针）。 在查看func4对应的代码之前，先观察执行callq 400fce 指令之后phase_4的操作：test %eax,%eax指令检查%eax的值是否等于0，如果不等于0，则会引爆炸弹，否则执行指令cmpl $0x0,0xc(%rsp），该指令将输入的第二个数与0做比较，如果相等，那么phase_4正常退出，拆弹成功。所以phase_4第二个输入值即为0 经过以上的分析，可以意识到phase_4的核心目标在于要让func4执行后，%eax的值等于0，这取决于输入的第一个数。接着需要分析func4执行的操作。 传递到func4的三个参数分别存储于寄存器%edi、%esi和%edx，其值分别为x(输入的第一个数)、0、14。 在0x400fe9处执行了指令callq 400fce ，因此func4很可能是个递归函数，我们将func4翻译成等价的C代码，如下所示。 123456789101112131415161718void func4(int x, int y, int z) &#123; int t = z - y; int k = t &gt;&gt; 31; t = (t + k) &gt;&gt; 1; k = t + y; if(k &lt;= x) &#123; t = 0; if(k &gt;= x) &#123; return; &#125;else &#123; y = k + 1; func4(x, y, z); &#125; &#125;else &#123; z = k - 1; func4(x, y, z); &#125;&#125; func4的目的是要让函数退出后%eax的值为0，而在0x400ff2处mov $0x0,%eax显示的将%eax的值设置为0，该指令对应于C代码中的t = 0。 并且，func4执行递归的退出条件为k == x，其中x对应于输入的第一个数，而k则可以通过一系列计算得到，由于y = 0且z = 14，易知k = 7 因此输入的第一个数即为7。将字符串7 0作为phase_4的输入 phase_512345678910111213141516171819202122232425262728293031323334353637383940410000000000401062 &lt;phase_5&gt;: 401062: 53 push %rbx 401063: 48 83 ec 20 sub $0x20,%rsp 401067: 48 89 fb mov %rdi,%rbx 40106a: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 401071: 00 00 401073: 48 89 44 24 18 mov %rax,0x18(%rsp) 401078: 31 c0 xor %eax,%eax #将%eax清零 40107a: e8 9c 02 00 00 callq 40131b &lt;string_length&gt; #函数调用 40107f: 83 f8 06 cmp $0x6,%eax #6和函数返回值比较 401082: 74 4e je 4010d2 &lt;phase_5+0x70&gt; #相同跳转 401084: e8 b1 03 00 00 callq 40143a &lt;explode_bomb&gt; #不相同爆炸 401089: eb 47 jmp 4010d2 &lt;phase_5+0x70&gt; 40108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx #循环开始 40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx 401096: 83 e2 0f and $0xf,%edx 401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx 4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) 4010a4: 48 83 c0 01 add $0x1,%rax 4010a8: 48 83 f8 06 cmp $0x6,%rax 4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; #循环结束 4010ae: c6 44 24 16 00 movb $0x0,0x16(%rsp) 4010b3: be 5e 24 40 00 mov $0x40245e,%esi 4010b8: 48 8d 7c 24 10 lea 0x10(%rsp),%rdi 4010bd: e8 76 02 00 00 callq 401338 &lt;strings_not_equal&gt; 4010c2: 85 c0 test %eax,%eax 4010c4: 74 13 je 4010d9 &lt;phase_5+0x77&gt; 4010c6: e8 6f 03 00 00 callq 40143a &lt;explode_bomb&gt; 4010cb: 0f 1f 44 00 00 nopl 0x0(%rax,%rax,1) 4010d0: eb 07 jmp 4010d9 &lt;phase_5+0x77&gt; 4010d2: b8 00 00 00 00 mov $0x0,%eax #返回值置0 4010d7: eb b2 jmp 40108b &lt;phase_5+0x29&gt; #跳转 4010d9: 48 8b 44 24 18 mov 0x18(%rsp),%rax 4010de: 64 48 33 04 25 28 00 xor %fs:0x28,%rax 4010e5: 00 00 4010e7: 74 05 je 4010ee &lt;phase_5+0x8c&gt; 4010e9: e8 42 fa ff ff callq 400b30 &lt;__stack_chk_fail@plt&gt; 4010ee: 48 83 c4 20 add $0x20,%rsp 4010f2: 5b pop %rbx 4010f3: c3 retq %rdi寄存器存储的是第一个参数的值，由于输入的是字符串，因此%rdi存储的应该是输入字符串的起始地址。 0x401067处的指令 mov %rdi,%rbx 将字符串起始地址保存在%rbx中，即%rbx为基址寄存器。 指令xor %eax,%eax的作用是将%eax清零 接着调用string_length函数获取输入字符串的长度，并将长度值（返回值）存储于%eax。 指令cmp $0x6,%eax 将string_length 的返回值与常数6作比较，若不相等则会引爆炸弹，由此可以得知，phase_5的输入字符串长度应该等于6. 当输入字符串的长度等于6，跳转至0x4010d2处执行指令mov $0x0,%eax， 接着又跳转至0x40108b处执行指令movzbl (%rbx,%rax,1),%ecx 可以发现0x40108b至0x4010ac构成了一个循环 且在循环退出后在0x4010bd处调动了strings_not_equal来比较字符串是否相等，若相等，则拆弹成功。 其中，由mov $0x40245e,%esi指令可知，待比较的字符串存储于地址0x40245e处， 打印以该地址作为起始地址的字符串 待比较的字符串为flyers，且长度也为6。 所以，接下来的关键任务是需要对循环操作进行分析，理解该循环操作对输入字符串做了哪些操作。提取循环操作的代码 12345678940108b: 0f b6 0c 03 movzbl (%rbx,%rax,1),%ecx #rbx+rax*1得到的结果零扩展成双字然后给ebx40108f: 88 0c 24 mov %cl,(%rsp) 401092: 48 8b 14 24 mov (%rsp),%rdx #通过cl间接把ecx的低八位储存到rdx中401096: 83 e2 0f and $0xf,%edx #edx和0xf按位与，以0x4024b0为基址，将偏移后的值存储至%edx。401099: 0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx #位与后的值将会作为偏移量4010a0: 88 54 04 10 mov %dl,0x10(%rsp,%rax,1) #以%edx低8位的值作为新的字符，对原有字符进行替换。4010a4: 48 83 c0 01 add $0x1,%rax4010a8: 48 83 f8 06 cmp $0x6,%rax4010ac: 75 dd jne 40108b &lt;phase_5+0x29&gt; 由于%rbx存储的是输入字符串的起始地址，%rax初始化为0，其作用等价于下标 因此movzbl (%rbx,%rax,1),%ecx 指令的作用是将字符串的第%rax个字符存储于%ecx（第三个参数），movzbl意味做了零扩展（目的操作数中的剩余字节设为0）（符号扩展）。 接着，mov %cl,(%rsp)指令取%ecx的低8位，即一个字符的大小，通过内存间接存储至%rdx中。 and $0xf,%edx指令将%edx的值与常数0xf进行位与 由指令movzbl 0x4024b0(%rdx),%edx可知，位与后的值将会作为偏移量，以0x4024b0为基址，将偏移后的值存储至%edx。 最后，指令mov %dl,0x10(%rsp,%rax,1)以%edx低8位的值作为新的字符，对原有字符进行替换。 综上，phase_5遍历输入字符串的每个字符，将字符的低4位作为偏移量，以0x4024b0为起始地址，将新地址对应的字符替换原有字符，最终得到flyers字符串。打印0x4024b0处的内容，如下图所示。 例如，如果要得到字符f，那么偏移量应为9，二进制表示为1001，通过查找ASCII表，可知字符i的ASCII编码为01101001，满足要求。剩余5个字符采用同样的策略可以依次求得，最终，phase_5的输入字符串为ionefg。 phase_612345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311400000000004010f4 &lt;phase_6&gt;: 4010f4: 41 56 push %r14 4010f6: 41 55 push %r13 4010f8: 41 54 push %r12 4010fa: 55 push %rbp 4010fb: 53 push %rbx 4010fc: 48 83 ec 50 sub $0x50,%rsp 401100: 49 89 e5 mov %rsp,%r13 401103: 48 89 e6 mov %rsp,%rsi 401106: e8 51 03 00 00 callq 40145c &lt;read_six_numbers&gt; 40110b: 49 89 e6 mov %rsp,%r14 # %r14存储数组起始地址 40110e: 41 bc 00 00 00 00 mov $0x0,%r12d # 将%r12d初始化为0 # Section 1:确认数组中所有的元素小于等于6且不存在重复值 401114: 4c 89 ed mov %r13,%rbp # %r13和%rbp存储数组某个元素的地址，并不是第1个元素，意识到这点需要结合0x40114d处的指令 401117: 41 8b 45 00 mov 0x0(%r13),%eax # %eax存储第%r13个数 40111b: 83 e8 01 sub $0x1,%eax # 将%eax的值减1 40111e: 83 f8 05 cmp $0x5,%eax # 将%eax的值与常数5做比较 401121: 76 05 jbe 401128 &lt;phase_6+0x34&gt; 401123: e8 12 03 00 00 callq 40143a &lt;explode_bomb&gt; 401128: 41 83 c4 01 add $0x1,%r12d # 如果%eax的值小于等于5，%r12d加1 40112c: 41 83 fc 06 cmp $0x6,%r12d # 将%r12d与常数6做比较 401130: 74 21 je 401153 &lt;phase_6+0x5f&gt; 401132: 44 89 e3 mov %r12d,%ebx # %ebx起了数组下标的作用 # 用于判断数组6个数是否存在重复值，若存在，引爆炸弹 401135: 48 63 c3 movslq %ebx,%rax # 将数组下标存储至%rax 401138: 8b 04 84 mov (%rsp,%rax,4),%eax # 将下一个数存储至%eax 40113b: 39 45 00 cmp %eax,0x0(%rbp)# 将第1个数与%eax的值(当前数)做比较 40113e: 75 05 jne 401145 &lt;phase_6+0x51&gt; # 若相等，引爆炸弹 401140: e8 f5 02 00 00 callq 40143a &lt;explode_bomb&gt; 401145: 83 c3 01 add $0x1,%ebx # 数组下标加1 401148: 83 fb 05 cmp $0x5,%ebx # 判断数组下标是否越界(&lt;=5) 40114b: 7e e8 jle 401135 &lt;phase_6+0x41&gt; 40114d: 49 83 c5 04 add $0x4,%r13 # %r13存储数组下一个数的地址 401151: eb c1 jmp 401114 &lt;phase_6+0x20&gt; # Section 1 end # Section 2：用7减去数组的每个元素，并将相减后的元素替换原有元素 401153: 48 8d 74 24 18 lea 0x18(%rsp),%rsi # 0x18(%rsp)是数组的边界地址：0x18 = 24 401158: 4c 89 f0 mov %r14,%rax # 将数组起始地址存储于%rax 40115b: b9 07 00 00 00 mov $0x7,%ecx 401160: 89 ca mov %ecx,%edx # %edx = 7 401162: 2b 10 sub (%rax),%edx # %edx = 7 - 数组元素 401164: 89 10 mov %edx,(%rax) # 用相减后的元素(%edx)替换原有元素 401166: 48 83 c0 04 add $0x4,%rax # %rax存储数组下一个元素的地址 40116a: 48 39 f0 cmp %rsi,%rax # 判断是否越界 40116d: 75 f1 jne 401160 &lt;phase_6+0x6c&gt;# Section 2 end # Section 3：根据输入数组重排结构体数组 40116f: be 00 00 00 00 mov $0x0,%esi # 将%esi初始化为0，作为数组下标 401174: eb 21 jmp 401197 &lt;phase_6+0xa3&gt; 401176: 48 8b 52 08 mov 0x8(%rdx),%rdx # 0x8(%rdx)为下一个元素的地址 40117a: 83 c0 01 add $0x1,%eax 40117d: 39 c8 cmp %ecx,%eax # %ecx存储了数组当前值(第%esi个元素) 40117f: 75 f5 jne 401176 &lt;phase_6+0x82&gt; 401181: eb 05 jmp 401188 &lt;phase_6+0x94&gt; 401183: ba d0 32 60 00 mov $0x6032d0,%edx # %edx存储结构体数组第1个元素的地址 401188: 48 89 54 74 20 mov %rdx,0x20(%rsp,%rsi,2) # %rsi的初始值为0；该指令的作用是将结构体数组的第%ecx个元素的地址存储在内存的某个位置(以%rsp + 0x20为基地址，%rsi为偏移量) 40118d: 48 83 c6 04 add $0x4,%rsi # 增加偏移量 401191: 48 83 fe 18 cmp $0x18,%rsi 401195: 74 14 je 4011ab &lt;phase_6+0xb7&gt; 401197: 8b 0c 34 mov (%rsp,%rsi,1),%ecx # %ecx存储数组第%esi个元素 40119a: 83 f9 01 cmp $0x1,%ecx # 将数组第%esi个元素与常数1做比较 40119d: 7e e4 jle 401183 &lt;phase_6+0x8f&gt; # 实际上不会小于1，如果数组的第1个元素等于1，那么跳转至0x401183处 40119f: b8 01 00 00 00 mov $0x1,%eax 4011a4: ba d0 32 60 00 mov $0x6032d0,%edx# %edx存储结构体数组第1个元素的地址 4011a9: eb cb jmp 401176 &lt;phase_6+0x82&gt;# Section 3 end # Section 4：修改结构体数组元素的next域值 4011ab: 48 8b 5c 24 20 mov 0x20(%rsp),%rbx # %rbx存储地址数组的第1个元素的值 4011b0: 48 8d 44 24 28 lea 0x28(%rsp),%rax# %rax存储地址数组的第2个元素的地址 4011b5: 48 8d 74 24 50 lea 0x50(%rsp),%rsi 4011ba: 48 89 d9 mov %rbx,%rcx # %rcx存储地址数组的第1个元素的值 # 下面用i和i+1来表示元素位置 4011bd: 48 8b 10 mov (%rax),%rdx # %rdx存储地址数组的第i+1个元素的值 4011c0: 48 89 51 08 mov %rdx,0x8(%rcx) # 把第i+1和元素的值存储于第i个结构体元素的next域中，next域的地址为0x8(%rcx)的值 4011c4: 48 83 c0 08 add $0x8,%rax 4011c8: 48 39 f0 cmp %rsi,%rax 4011cb: 74 05 je 4011d2 &lt;phase_6+0xde&gt; 4011cd: 48 89 d1 mov %rdx,%rcx 4011d0: eb eb jmp 4011bd &lt;phase_6+0xc9&gt;# Section 4 end # Section 5：判断结构体数组是否是递减序列 4011d2: 48 c7 42 08 00 00 00 movq $0x0,0x8(%rdx) 4011d9: 00 4011da: bd 05 00 00 00 mov $0x5,%ebp 4011df: 48 8b 43 08 mov 0x8(%rbx),%rax 4011e3: 8b 00 mov (%rax),%eax 4011e5: 39 03 cmp %eax,(%rbx) 4011e7: 7d 05 jge 4011ee &lt;phase_6+0xfa&gt; 4011e9: e8 4c 02 00 00 callq 40143a &lt;explode_bomb&gt; 4011ee: 48 8b 5b 08 mov 0x8(%rbx),%rbx 4011f2: 83 ed 01 sub $0x1,%ebp 4011f5: 75 e8 jne 4011df &lt;phase_6+0xeb&gt;# Section 5 end 4011f7: 48 83 c4 50 add $0x50,%rsp 4011fb: 5b pop %rbx 4011fc: 5d pop %rbp 4011fd: 41 5c pop %r12 4011ff: 41 5d pop %r13 401201: 41 5e pop %r14 401203: c3 retq 将phase_6划分为5个Section，每个Section完成特定的功能，详细的注释直接附到了相关代码。前两个Section不难理解：Section 1确保输入数组的值的范围在1 ~ 6且不存在重复值；Section 2用7减去输入数组的每个元素，相当于求补。Section 3中出现了一个常数地址，使用gdb将该地址存储的内容打印出来，如下图所示。 可以意识到这其实是一个链表数据结构，链表的节点由3部分组成：value 1、value 2和一个地址值(next域，指向下一个节点)。Section 3根据我们输入的数组，按照数组元素的值将对应结构体数组中的元素的首地址存储到内存的某个位置(mov %rdx,0x20(%rsp,%rsi,2))。例如，假设输入数组为[3, 4, 5, 6, 1, 2]，那么Section 3首先会将结构体数组的第3个元素的地址存储到0x20(%rsp,%rsi,2)处，接着将结构体数组的第4个元素……依次类推。 Section 4根据Section 3构建的地址数组，修改结构体数组的next域的值，实现单链表的排序操作。Section 5进行验证，要求单链表递减排序，若满足要求，那么拆弹成功。 综上，根据已有的结构体数组以及phase_6的操作，若要实现单链表的递减排序，应将第3个节点放在第1位，将第4个节点放在第2位……最终得到序列：[3, 4, 5, 6, 1, 2]。不要忘记Section 2中的求补操作，所以phase_6的输入序列应该为[4, 3, 2, 1, 6, 5]。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-12]]></title>
    <url>%2F2019%2F02%2F27%2FCSAPP-12%2F</url>
    <content type="text"><![CDATA[逻辑设计和硬件控制语言HCL逻辑设计逻辑门：数字电路的基本计算元素，物理结构与逻辑结构的映射，实质是晶体管。输出是输入的布尔函数。 一个逻辑门计算一位 组合电路需要遵循的原则 两个逻辑门的输出不能连到一起。 组合的电路必须是无环的。输出不能再当输入 HCL表达式与C表达式区分 逻辑门是持续输出的，但C语言表达式是执行到的时候才会求值。这个区别可以把逻辑门当成一个电路来看，电路是不能断电的，电流会一直存在。 C语言中输出可以是任意整数，而HCL只能是1和0。这点比较好理解。 对于a &amp;&amp; b这个符号来说，C语言中的规定是如果前者为假，则后者不会再计算。而HCL当中没有这种说法。 按位计算位相等： 位多路复用器： 多位运算就是多个一位一起运算 32位看是否相等： s的not被多次用到，否则需要32个not门。 HCL条件选择表达式的条件不需要互斥，按照优先顺序依次选取 集合形式的HCL表达式，需要一个输入信号与某些值匹配 储存器和时钟储存器一般两种： 时钟寄存器。储存单个位或单个字，时钟信号控制是否加载输入的值 随机访问储存器。储存多个字，地址来选择 寄存器文件和随即访问储存器有读写操作，时钟寄存器没有读写。 寄存器文件两个读端口，一个写端口，端口都带地址标识操作寄存器。 随即访问储存器只有一个地址输入和一个数据输出]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-11]]></title>
    <url>%2F2019%2F02%2F25%2FCSAPP-11%2F</url>
    <content type="text"><![CDATA[Y86指令体系结构Y86的程序猿可见状态：寄存器，储存器，条件码，PC，程序状态 Y86指令集 halt：终止指令的执行 nop：占位指令，不做任何事 **movl：一系列数据传送指令。r代表寄存器，m代表储存器，i代表立即数。 opl：操作指令 jxx：条件跳转指令，根据后面的条件进行跳转 cmovxx：条件传送指令。xx是条件，只发生在两个寄存器之间 call与ret：方法的调用和返回指令。一个将返回地址入栈，并跳到目标地址。一个将返回地址入PC，并跳到返回地址。 push与pop：入栈和出栈操作 指令编码一般两个寄存器占用一个字节，储存器占四个字节，指令的编码和功能占一个字节。 寄存器的表示：4个二进制位 Y86异常Y86的四种不同状态码：AOK（正常）、HLT（执行halt指令）、ADR（非法地址）、INS（非法指令） Y86程序和x86相似，但有时候Y86需要两条指令来达到X86只要一条即可 eg：addl $4,%ecx]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-10]]></title>
    <url>%2F2019%2F02%2F23%2FCSAPP-10%2F</url>
    <content type="text"><![CDATA[数组的分配与访问动态数组…咋就那么复杂 1234567891011int sum(int n)&#123; int a[n]; int i,sum; for(i = 0 ; i &lt; n; i++)&#123; a[i] = i * 3; &#125; for(i = 0 ; i &lt; n; i++)&#123; sum += a[i]; &#125; return sum;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 .file &quot;t.c&quot; .text .globl sum .type sum, @functionsum:.LFB0: /*栈帧建立，被调用者保存寄存器的备份，栈内存分配*/ .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp .cfi_def_cfa_register 6 subq $16, %rsp /*栈帧建立，被调用者保存寄存器的备份，栈内存分配*/ /*动态数组分配内存*/ movq %fs:40, %rcx movq %rcx, -8(%rbp) xorl %ecx, %ecx movslq %edi, %rdx leaq 18(,%rdx,4), %rdx andq $-16, %rdx //分配长度为（18+4n）&amp;（-16）的值 /*动态数组分配内存*/ subq %rdx, %rsp movq %rsp, %rcx movl $0, %edx jmp .L2.L3: leal (%rdx,%rdx,2), %r8d movslq %edx, %rsi movl %r8d, (%rcx,%rsi,4) addl $1, %edx.L2: cmpl %edi, %edx jl .L3 movl $0, %edx jmp .L4.L5: movslq %edx, %rsi addl (%rcx,%rsi,4), %eax addl $1, %edx.L4: cmpl %edi, %edx jl .L5 movq -8(%rbp), %rcx xorq %fs:40, %rcx jne .L8 leave .cfi_remember_state .cfi_def_cfa 7, 8 ret.L8: .cfi_restore_state call __stack_chk_fail@PLT .cfi_endproc.LFE0: .size sum, .-sum .ident &quot;GCC: (Ubuntu 7.3.0-27ubuntu1~18.04) 7.3.0&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 头大…… 异质结构与数据对齐异质结构：不同数据类型的数组组合 数据对齐：为了提高数据读取速度，会将数据以2的指数倍对齐，具体数字根据硬件设施和操作系统确定。但浪费了储存空间。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-9]]></title>
    <url>%2F2019%2F02%2F21%2FCSAPP-9%2F</url>
    <content type="text"><![CDATA[过程栈帧的结构栈帧是程序栈的一段，程序栈是储存器的一段。 起始地址：储存在%ebp寄存器（桢指针） 结束地址：储存在%esp寄存器（栈顶指针） 栈指针会在运行时移动，所以大部分时候，在访问存储器的时候会基于帧指针访问，因为在一直移动的栈指针无法根据偏移量准确的定位一个存储器位置。 过程的实现 备份原来指针 12pushl %ebpmovl %esp, %ebp 给临时变量分配预留内存 1subl $16,%esp 值压入栈顶（备份） 1pushl %ebx 使用建立好的栈帧，mov,push,pop 从栈帧中将备份的值恢复到寄存器 释放被调用的栈帧，栈指针增大 1movl %ebp,%esp 调整栈帧两端,第六步调整了栈指针， 只需要将备份的原桢指针弹到%ebp 1popl %ebp 弹出返回地址，跳出当前过程，继续执行调用者的代码。（ret） 过程相关指令:call、leave、retcall:将返回地址压入栈顶，将程序跳转到当前调用的方法的起始地址。 leave：栈指针指向桢指针，弹出备份的原桢指针到%ebp ret：栈顶的返回值弹出到PC，按照PC指示的指令地址继续执行程序。 寄存器的使用规则%eax、%edx、%ecx：调用者保存寄存器。这三个寄存器由调用者P来保存，而对于Q来说，Q可以随便使用，用完了就不用再管了。 %ebx、%esi、%edi：被调用者保存寄存器。这三个寄存器由被调用者Q来保存，Q可以使用这三个寄存器，但是如果里面有P的变量值，Q必须保证使用完以后将这三个寄存器恢复到原来的值，这里的备份，其实就是上面那8个步骤中第3个步骤做的事情。]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-8]]></title>
    <url>%2F2019%2F02%2F17%2FCSAPP-8%2F</url>
    <content type="text"><![CDATA[接上一篇说最复杂的条件码寄存器组合 所有组合都是基于a-b的前提。 后缀 逻辑运算（值为1） 描述 e ZF 相等。此时ZF为1，a-b=0，相等 ne ~ZF 反之 s SF 负数。SF为1，设b=0，即a&lt;0 ns ~SF 反之 l SF^OF 有符号的小于。当OF为0时，则代表没有溢出，此时SF必须为1，SF为1则代表结果为负。即a-b&lt;0，也就是a&lt;b，也就是小于的意思。 当OF为1时，则代表产生了溢出，而此时SF必须为0，也就是说结果最后为正数，那么此时则是负溢出，也可以得到a-b&lt;0，即a&lt;b. le (SF^OF)\ ZF 有符号的小于等于。括号里代表小于，和等于作或运算 g (SF^OF)&amp;~ZF 有符号的大于。小于且不等于 ge ~(SF^OF) 有符号的大于等于。不小于 b CF 无符号的小于。无符号减法只有在减出负数的时候才可能溢出，也就是说只要结果溢出了，那么一定有a-b&lt;0 be CF\ ZF 无符号的小于等于。 a ~CF&amp; ~ZF 无符号的大于。无符号大于等于且不等于 ae ~CF s无符号大于等于]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-7]]></title>
    <url>%2F2019%2F02%2F17%2FCSAPP-7%2F</url>
    <content type="text"><![CDATA[控制真的是看的很懵，很多地方理解不了…… 条件码寄存器 条件码寄存器 描述 CF 进位标志寄存器。最近的操作使最高位产生了进位，无符号操作溢出时为1 ZF 零标志寄存器。最近的操作得出的结果是0时为1 SF 符号标志寄存器。最近的操作得到的结果为负数时为1 OF 溢出标志寄存器。最近的操作导致一个补码溢出时为1 条件码寄存器大多数时候是被动改变 特殊的测试指令cmp和test是唯二可以主动设置条件码寄存器的指令 cmp S1，S2：基于S1-S2的值来设置条件码 test S2，S1：基于S2&amp;S1去设置条件码 二者都需加数据格式后缀 访问条件码寄存器 根据条件码组合，将一个字节设置为0，1 条件跳转到程序的某个其他部分 有条件的传送数据 第一种是直接读取条件码寄存器的值，二三种是直接使用，不会显示的读取条件码寄存器的值 条件码寄存器的组合这块好难啊……下一篇再细说 SET指令将条件码组合的值设置到指定的目的操作数，目的操作数只能是单字节的寄存器或储存器中单字节的位置 跳转指令直接将程序跳转到指定位置，或者根据条件码寄存器的组合进行条件跳转。除了第一个jmp直接跳转指令以及第二个jmp间接跳转指令之外，剩下的12个都是条件跳转指令。 总的来说，跳转指令包含给出一个偏移量和给出绝对地址两种 流程控制c代码（随便写的） 12345678910111213141516171819202122232425262728int jmp(int a,int b)&#123; int i; if(a==b) return a; for (i=0;i&lt;5;i++) &#123; a++; &#125; while (b&lt;10) &#123; b++; &#125; do &#123; i++; &#125; while (a&gt;=i); switch (a) &#123; case 1:a+=10; break; case 2:a+=20; break; case 5:a+=30; break; &#125; return a; &#125; 汇编代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 .file &quot;t.c&quot; .text .globl jmp .type jmp, @functionjmp:.LFB0: .cfi_startproc /*if实现判断*/ cmpl %esi, %edi //比较a,b je .L11 //如果相等，跳到.L11，返回a movl $0, %edx //如果不相等，进行for循环，把0赋给i jmp .L3 //跳到.L3 /*if实现判断*/ /*for循环实现*/.L4: addl $1, %edi //a自加 addl $1, %edx //i自加.L3: cmpl $4, %edx // i和4比较 jle .L4 // i小于或等于4则跳到.L4 jmp .L5 //i大于4则跳到.L5,进行do while循环 /*for循环实现*/ /*do while循环实现*/.L6: addl $1, %esi //b自加.L5: cmpl $9, %esi //b和9比较 jle .L6 //b小于或等于9，则跳至.L6自加.L7: addl $1, %edx //i自加 cmpl %edx, %edi //a和i比较 jge .L7 //a大于或等于i则跳到.L7开头 /*do while循环实现*/ /*switch语句实现*/ cmpl $2, %edi //a和2比较 je .L8 //如果a=2，跳至.L8 cmpl $5, %edi //a和5比较 je .L9 //a=5则跳至.L9 cmpl $1, %edi //a和1比较 je .L14 //a=1则跳至.L14 movl %edi, %eax //取a作为返回值 ret.L14: leal 10(%rdi), %eax //计算10+a并作为返回值 ret.L8: leal 20(%rdi), %eax //计算20+a作为返回值 ret.L9: leal 30(%rdi), %eax //计算30+a作为返回值 ret.L11: movl %edi, %eax 取a作为返回值 ret .cfi_endproc.LFE0: .size jmp, .-jmp .ident &quot;GCC: (Ubuntu 7.3.0-27ubuntu1~18.04) 7.3.0&quot; .section .note.GNU-stack,&quot;&quot;,@progbits cmov指令满足条件的时候进行传送，与set比较像 条件传送指令相当于if-else的赋值判断，一般情况下，比if-else性能好]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-6]]></title>
    <url>%2F2019%2F02%2F15%2FCSAPP-6%2F</url>
    <content type="text"><![CDATA[算术和逻辑操作 加载有效地址leaq：将有效地址写入目的操作数，目的操作数必须是一个寄存器 一元和二元操作一元：一个操作数 二元：俩个操作数 移位操作移位量，要移位的数。 移位量可以是立即数，或者放在单字节寄存器%cl中；目的操作数：寄存器或者内存位置 高位被忽略，eg：salb移7位…… 左移：SAL、SHL右边都是填0 右移：SAR左边填符号位。SHR左边填0 大多数指令既可以用于无符号运算，也可以用于补码运算，只有右移操作要求区分有符号和无符号数 特殊的算术操作]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-5]]></title>
    <url>%2F2019%2F02%2F13%2FCSAPP-5%2F</url>
    <content type="text"><![CDATA[代码机器代码 程序计数器（PC）%rip给出将要执行的下一条指令在内存中的地址 整数寄存器文件包含16个命名的位置，储存地址或者整数数据。 条件码寄存器保存最近执行的算术或逻辑指令的状态信息。实现控制或数据流中的条件变化。 一组向量寄存器可以存放一个或多个整数或浮点数值 虚拟地址（64位）的高十六位必须设置为0 查看汇编代码（—&gt;test.s) 1linux&gt; gcc -Og -S test.c 编译并汇编该代码(—&gt;test.o) 1linux&gt; gcc -Og -c test.c GCC产生的汇编代码指令上有后缀，而反汇编代码没有，x86-64的内存引用都是四字长寄存器给出。 反汇编器：根据机器代码生成一种类似于汇编代码的格式。 查看机器代码文件的内容： 1linux&gt; objdump -d matore.o 访问信息整数寄存器： 操作数指示符立即数：常数 ($(C常数表示法)) 寄存器：某个寄存器的内容 内存引用：根据计算出的地址，访问地址 数据传送指令MOV类：把数据从源位置复制到目的位置 源操作数是一个储存在寄存器或者内存中的立即数 目的操作数是个寄存器或者内存地址（位置），不能是立即数寻址 x86-64:两操作数不能都指向内存位置。 指令 描述 movb（8） 传送字节 movw（16） 传送字 movl（32） 传送双字，以寄存器为目的时，把寄存器高位4字节设置为0 movq（64） 传送四字 movabsq 传送绝对的四字 一脸懵逼orz…… 字节传送指令比较（16进制） 指令 描述 movb 不改变其他字节 movsbq 把其他字节设为FF movzbq 把其他字节设为00 压入和弹出栈数据pushq：把数据压入到栈上 popq：弹出数据 %rsp：栈指针，保存栈顶元素地址 压入四字节：先减去8(栈倒过来放），然后将值写入新的栈顶地址。 12subq $8,%rspmovq %rbp,(%rsp) 弹出四字节：读出数据，加上8 12movq（%rsp），%raxaddq $8,%rsp]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-4（浮点数）]]></title>
    <url>%2F2019%2F02%2F11%2FCSAPP-4%2F</url>
    <content type="text"><![CDATA[bomb lab题目都找不到……所以，又回来啃书了…… 舍入 向偶数舍入（默认）：找到最接近的匹配值，如果是5，则使结果的最低有效数字是偶数。 向零舍入：正数向下舍入，负数向上舍入 向上舍入：大于该数的最小整数 向下舍入：不大于该数的最大整数 IEEE浮点表示$$V=(-1)^s\times M\times 2^E$$ 符号位（s），阶码字段(E)，小数字段(M) 规格化的值 E的位模式不全为0也不全为1，此时，阶码的值E=e-Bias(偏置值：单精度：127；双精度：1023)，小数字段:[0,1]. 非规格化的值 阶码域全为0，E=1-Bias 特殊值 阶码全为1。小数域全为0时，得到的值表示无穷（s=0：正无穷，s=1:负无穷），小数域非0，结果值被称为NaN。 整数转换为浮点数创造规格化表示，用IEEE形式编码，构造小数字段，构造阶码字段]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP-datalab]]></title>
    <url>%2F2019%2F02%2F11%2FCSAPP-datalab%2F</url>
    <content type="text"><![CDATA[看CSAPP看的实在是绝望，觉得假期肯定啃不完，所以决定先做实验，遇见不会的再翻书，过年这一个多周的时间，做了下datalab bitAnd题目：只能用～和|来实现位的与操作。 bitAnd - x&amp;y using only ~ and | Example: bitAnd(6, 5) = 4 Legal ops: ~ | Max ops: 8 Rating: 1 思路：~x：非x，~y：非y，那么~x|~y就是既不是x也不是y，那~（~x|~y）就是既是x也是y，也就是x与y 1234int bitAnd(int x,int y)&#123; return (~(~x|~y));&#125; getByte 题目：给定n （0&lt;=n&lt;=3），求出x第n个字节是哪数字。 getByte - Extract byte n from word x Bytes numbered from 0 (LSB) to 3 (MSB) Examples: getByte(0x12345678,1) = 0x56 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 6 Rating: 2 思路：（不做题觉得自己了解的还可以，一做题，就觉得，自己啥也没学到……） 第一感觉和CSAPP书上的一道习题挺像，移位运算，用0xFF移动n个字节，然后&amp;一下 123456int getByte(int x,int n)&#123; int temp=x&gt;&gt;((n)&lt;&lt;3); temp=temp&amp;0xFF; return temp;&#125; logicalShift题目：将x按逻辑位移移动n（0&lt;=n&lt;=31）位。 logicalShift - shift x to the right by n, using a logical shift Can assume that 0 &lt;= n &lt;= 31 Examples: logicalShift(0x87654321,4) = 0x08765432 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 20 Rating: 3 思路： 一开始想定义的时候直接unsigned不就好了吗？觉得那这道题就没有意义了。先进行算术右移，然后将右移产生的1mask掉,关键是mask怎么构造，范围是0~31，那1左移31位，然后取反，就是0111……1，然后右移n位，左移1位这样就出来了0…0011…1110，然后加个1，就出来了 123456int logicalShift(int x,int n)&#123; int x1=x&gt;&gt;n; int mask=(~（1&lt;&lt;31)&gt;&gt;n&lt;&lt;1)+1 return X1&amp;mask；&#125; bitCount题目：用位运算计算出x中有多少个1 bitCount - returns count of number of 1’s in word Examples: bitCount(5) = 2, bitCount(7) = 3 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 40 Rating: 4 思路：一位一位的右移，然后看奇偶数，然后进行统计，但是不能用==，/，所以没有了思路。整道题看writeup，还是不懂，看完书再说。分治 bang题目：不用！运算符求出！x结果 bang - Compute !x without using ! Examples: bang(3) = 0, bang(0) = 1 Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 12 Rating: 4 思路：一开始还是想用if，感觉自己还是没找到感觉。这个题就是找0和其他数之间的区别，0|0肯定还是0，但0|1=1，除了0以外，其他数都有1，所以想从这个方面入手。但是没有思路啊，看了别人的才知道，除了0，任何数自己|上自己的相反数最高位一定是1，那就好说了，直接|一下相反数，移位一下就OK 1234567int bang(int x)&#123; int x1=~x+1; x=x|x1; x=x&gt;&gt;31; x=x+1；&#125; tmin题目：返回补码整数的最小整数数值。 tmin - return minimum two’s complement integer Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 4 Rating: 1 思路：这不就是返回一个确定的值吗？ 1234int tmin(void)&#123; return 0x80 &lt;&lt; 24;&#125; fitsBits 题目：只给出n个二进制位，能否表示x,能返回1. fitsBits - return 1 if x can be represented as an n-bit, two’s complement integer. 1 &lt;= n &lt;= 32 Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 15 Rating: 2 思路：因为在前面的bitCount，我在歪路上想了怎么能知道移位移到了最后一位，也就是怎么知道x转为二进制需要多少位，所以这个题就很简单了。将x右移n-1位，判断是不是全1或全0. 1234567int fitsBits(int x, int n)&#123; int x1 =~((~n)+1); x=x&gt;&gt;x1; int ans=(!tmpx|!(tmpx+1)); return ans;&#125; divpwr2题目：给出整数x，整数n，求[x/(2^n)]，答案要接近趋向0方向。 divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 Round toward zero Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 15 Rating: 2 思路：二进制的除就是右移，那就是x&gt;&gt;n.试了一下，只要x是负数，向下取整。首先判断是不是负数，(~( (x &gt;&gt; 31) &amp; 0x1) )+1，是负数构造出0xFF……FF出来，然后构造q=2^n-1 既~((~0)&lt;&lt;n)，如果既然是负数的话就可以加上(tmp &amp; q) 既 0x0…FFF，再右移动n位。 1234567int divpwr2(int x, int n)&#123; int tmp = (~( (x &gt;&gt; 31) &amp; 0x1) )+1 ; int q= ~((~0)&lt;&lt;n); int ans = (x + (tmp &amp; q) ) &gt;&gt; n ; return ans;&#125; negate题目：求相反数 negate - return -x Example: negate(1) = -1. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 5 Rating: 2 1234int negate(int x)&#123; return ((~x)+1)&#125; isPositive 题目:判断x是不是正数 isPositive - return 1 if x &gt; 0, return 0 otherwise Example: isPositive(-1) = 0. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 8 Rating: 3 思路：因为有0，所以不能看符号位，那就转换一下思路，取反，如果0，那么结果是1，如果为负数，那结果为正数，符号位为1，如果x为0或负数，那么!x | (x &gt;&gt; 31) != 0，再！一下就OK了 1234int isPositive(int x)&#123; return !(!x|(x&gt;&gt;31)); &#125; isLessOrEqual题目：用位运算判定x&lt;=y，如果是就返回1，如果不是就返回0。 isLessOrEqual - if x &lt;= y then return 1, else return 0 Example: isLessOrEqual(4,5) = 1. Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 24 Rating: 3 思路：分两种情况，同号和异号，异号比较一下符号位就好，同号x-y的符号位是不是0. 123456789int isLessOrEqual(int x, int y)&#123; int signx = (x &gt;&gt; 31); int signy = (y &gt;&gt; 31); int isSameSign=!(signx^signy) ; int p=!(((~x)+1+y)&gt;&gt;31); int ans=(isSameSign&amp;p)|((!isSameSign)&amp;signx); return ans;&#125; ilog2 题目：求整数的log(x)。 ilog2 - return floor(log base 2 of x), where x &gt; 0 Example: ilog2(16) = 4 Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; Max ops: 90 Rating: 4 思路：感觉和之前C程里解方程的实验应该差不多。二分法找最高位为1的位置。 12345678910int ilog2(int x)&#123; int num=0; num=(!!(x&gt;&gt;16))&lt;&lt;4; num=num+((!!(x&gt;&gt;(8+num)))&lt;&lt;3); num=num+((!!(x&gt;&gt;(4+num)))&lt;&lt;2); num=num+((!!(x&gt;&gt;(2+num)))&lt;&lt;1); num=num+((!!(x&gt;&gt;(1+num)))&lt;&lt;0); return num;&#125; float_neg题目：返回输入uf的负数形式-uf。如果uf是NAN形式就直接返回参数。 float_neg - Return bit-level equivalent of expression -f for floating point argument f. Both the argument and result are passed as unsigned int’s, but they are to be interpreted as the bit-level representations of single-precision floating point values. When argument is NaN, return argument. Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while Max ops: 10 Rating: 2 思路：题目读不懂，翻书+google，uf：unsigned float ； NaN（非数）:未定义或不可表示的值，先判断是不是NaN(&gt;0x2f800000)，是就直接返回，不是则取反 123456789unsigned float_neg(unsigned uf)&#123; unsigned result; unsigned tmp; result=uf^0x80000000; tmp=uf&amp;0x7fffffff; if(tmp&gt;0x7f800000) result=uf; return result;&#125; float_i2f题目：将int型的x转为float型的x。 float_i2f - Return bit-level equivalent of expression (float) x Result is returned as unsigned int, but it is to be interpreted as the bit-level representation of a single-precision floating point values. Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while Max ops: 30 Rating: 4 思路：没思路，翻书，感觉一到浮点数就一脸懵逼，完全没有概念，又是一道把别人的答案从头到尾看了好几遍的题，等看完书再说叭（头秃……）。 如果是0，直接返回即可 如果是0x80000000,返回0xcf000000 如果负数：变为整正数之后按照正数计算 正数：计算尾数部分左移还是右移，然后计算阶码，加上偏置值127，尾数向偶数舍入。 float_twice题目：就是将浮点数乘以2倍。 float_twice - Return bit-level equivalent of expression 2*f for floating point argument f. Both the argument and result are passed as unsigned int’s, but they are to be interpreted as the bit-level representation of single-precision floating point values. When argument is NaN, return argument Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while Max ops: 30 Rating: 4 嘤嘤嘤~浮点数真令人头大]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP_3]]></title>
    <url>%2F2019%2F02%2F01%2FCSAPP-3%2F</url>
    <content type="text"><![CDATA[无符号数编码$$B2U_\omega(\vec x)=\sum^{\omega-1}_{i=0}x_i2^i$$ $$eg:B2U_4([0001])=0•2^3+0•2^2+0•2^1+1•2^0=0+0+0+1=1$$ 无符号数编码唯一性 双射 补码编码$$B2T_\omega(\vec x)=-x_{\omega-1}2^{\omega-1}+\sum^{\omega-2}_{i=0}x_i2^i$$ 二进制数编码表示 原码 最左边一位为符号位（小数：小数点左边一位为符号位） +：0 —：1 反码 符号位不变，其他取反 补码 负数：反码末尾加一 正数：本身 有符号数和无符号数的转换 补码转换为无符号数$$T2U_\omega(x)=\begin{cases}x+2^\omega, x&lt;0\x,x\geq0\\end{cases}$$ 无符号数转换为补码$$U2T_\omega(u)=-u_{\omega-1}2^\omega+u$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP_2]]></title>
    <url>%2F2019%2F01%2F30%2FCSAPP-2%2F</url>
    <content type="text"><![CDATA[寻址和字节顺序 小端法：最低有效字节在最前面 大端法：最高有效字节在最前面 浮点型和整型数据有不同的字节模式 二进制代码不兼容 布尔代数 布尔运算 逻辑运算 ~ NOT &amp; AND 单竖线 OR ^ 异或（不同为1，相同为0） 位向量：固定长度，由0，1组成的串,1表示存在，0表示不存在，从右往左 布尔环 移位运算左移：右端补k个0，移位之后符号为不变，将一个整数左移1位相当于乘以2 逻辑右移：左端补k个0 算术右移：左端补k个最高有效位的值 意义 x&gt;&gt;k x右移k位 x&lt;&lt;k x左移k位 位级运算转换为二进制进行运算，之后转回相应进制 掩码运算 最常见：ch&amp;0xff，生成由ch最低有效字节组成的值 0xff的二进制形式为11111111，这样最终的值为最后8位不变，其他数均为0]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSAPP_1]]></title>
    <url>%2F2019%2F01%2F27%2FCSAPP-1%2F</url>
    <content type="text"><![CDATA[计算机系统 硬件 总线：贯穿整个系统的电子管道 I/O设备：系统和外部联系的通道 主存：执行程序时，存放相关数据 处理器：解释或执行储存在主存中指令中的引擎 软件 应用程序 操作系统 虚拟内存 C全局变量相对应的数据位紧跟在代码后面，一开始被制订大小 堆：紧跟在代码和数据区后面，可动态扩展和收缩 共享库 栈：虚拟地址空间顶部，实现函数调用，可动态扩展收缩 内核虚拟内存：地址空间顶部 并发和并行 并发：同时有多个活动的系统 并行：用并发使一个系统运行更快 抽象 文件是对I/O设备的抽象 虚拟内存是对主存和磁盘的抽象 进程是对正在运行的程序的抽象 虚拟机是对整个计算机的抽象]]></content>
  </entry>
  <entry>
    <title><![CDATA[ss科学上网]]></title>
    <url>%2F2019%2F01%2F26%2Fss%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%2F</url>
    <content type="text"><![CDATA[嗯……第一次更博，有点晚了，一直在弄，期间走了不少弯路，今天可算是弄好了。 一、vultr注册—&gt;绑定银行卡—&gt;建服务器 前两个就不细说了 Server Location: sydney Server Type：centos7 x64 Server Size: 按实际需要选 Deploy Now 接下来是漫长的等待…… 二、连接及搭建ss连接：1$ ssh root@IP 之后有一个要输入yes 之后是密码 一键搭建ss123wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 之后按照提示输入IP、端口、密码、加密方式 出现红框框的时候，恭喜，快要成功了…… 三、shadowsocks下载shadowsocks，然后打开，填好IP端口密码加密方式，其他默认就好。确定 bingo~ 以下为我走的弯路学到的知识一、新建centos7虚拟机 准备 VMware workstation 14 、镜像（https://www.centos.org/download/） 具体步骤 安装程序光盘映像文件，找到下载的路径 命名，选择位置 确定磁盘大小和是否拆分为多个文件 自定义硬件 选择使用ISO映像文件，并找到映像文件的路径 完成之后就可以打开虚拟机了 点黑色的地方，用上下键选第一条，漫长的等待…… 选择语言（ENGLISH） 确定日期和时间，语言，软件选择—&gt;GNOME桌面，开始安装 之后设置root和新建用户 这次是非常漫长的等待…… reboot! 设置网络，登陆，bingo~ 二、端口放行（操作防火墙）主要是三个命令 123firewall-cmd --zone=public --add-port=80/tcp --permanent //--zone :作用域 80/tcp:端口/传输协议 --permanent：没有这个重启以后还得再来一遍firewall-cmd --reloadiptables-save 第一条命令是添加端口，第二条命令是重载防火墙，第三条命令是查看开放的端口 ##同时用到的对防火墙的操作 1234firewall-cmd --state //查看防火墙状态systemctl stop firewalld.service //关闭防火墙systemctl start firewalld.service //开启防火墙systemctl disable firewalld.service //禁止firewall开机启动]]></content>
  </entry>
</search>
